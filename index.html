<!DOCTYPE html>
<html>
<head>
	<title>Cube-3D</title>

</head>
<body>

<script src='./node_modules/mathjs/lib/browser/math.js'></script>

<canvas id="canvas" width="600" height="600" style="background-color: #f5f0f0; display: block; margin: auto; margin-top: 50px; "></canvas> 


<script>


let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");

let size_cube = 2;

let point = [  //матрица с координатами 8-ми точек куба
//  X     Y   Z
    [-60,60,-60],
    [-60,-60,-60],
    [60,60,-60],
    [60,-60,-60],

    [-60,60,60],
    [-60,-60,60],
    [60,60,60],
    [60,-60,60],
];

let point_clone = [  
/*
   [-60,60,0],
    [-60,0,-60],
    [60,60,-60],
    [60,-60,-60],

    [-60,60,60],
    [-4444,-60,60],
    [60,60,60],
    [60,-60,60],*/

];

let line = [ //матрица содержащая инструкцию как и в каком порядке соединять ребра куба 

    [0,1], //одно ребро равно одной ячейки массива. содержимое это ячейки равно двум точкам которые нужно соединить
    [2,3], //например эта линия состоит из координат точки point[2] и точки point[3]
    [0,2],
    [1,3],

    [4,5],
    [6,7],
    [4,6],
    [5,7],

    [0,4],
    [1,5],
    [2,6],
    [3,7]

];

const focus_value = 250;

ctx.translate(300,300);// сдвиг системы координат


function rotate(angleX = 0.3 , angleY = 0.8, angleZ = 0 ){

    let rotationX = [

        [(1),                             (0),                                   (0)],

        [(0),  Math.cos(angleX* Math.PI / 180), Math.sin(angleX* Math.PI / 180)*(-1)],

        [(0),  Math.sin(angleX* Math.PI / 180), Math.cos(angleX* Math.PI / 180)     ]

    ];

    let rotationY = [
        
        [  Math.cos(angleY* Math.PI / 180), (0), Math.sin(angleY* Math.PI / 180)*(-1)],

        [(0),                             (1),                                   (0) ],

        [ Math.sin(angleY* Math.PI / 180), (0), Math.cos(angleY* Math.PI / 180)      ]

    ];

    let rotationZ = [

        [ Math.cos(angleZ* Math.PI / 180),      Math.sin(angleZ* Math.PI / 180), (0)],

        [ Math.sin(angleZ* Math.PI / 180)*(-1), Math.cos(angleZ* Math.PI / 180), (0)],

        [(0),                            (0),                                    (1)]

    ];





multiplay(rotationX);//поворот

multiplay(rotationY);

multiplay(rotationZ);

focus();

clear();//отчистка экрана 

draw();//отрисовка куба

}


setInterval(rotate, 10);//обновление анимации

function focus(){

    for (var i = 0; i < point.length; i++) {

    let val = multiplay_focus(point[i]);
    point_clone[i] = [];
    point_clone[i].push(val[0]);
    point_clone[i].push(val[1]);
    point_clone[i].push(val[2]);

}
}

function multiplay_focus(point){

    let distance = point[2] + 60;

    let tanget_x = point[0] / (focus_value + distance);

    let tanget_y = point[1] / (focus_value + distance);

    let new_x = focus_value * tanget_x;

    let new_y = focus_value * tanget_y;
    
    let arr = [];

    arr[0] = new_x;
    arr[1] = new_y;
    arr[2] = point[2];

    return arr;
}


function multiplay(axis){//умножение точек куба на матрицу поворота 
    for (var i = 0; i < point.length; i++) {

    let val = math.multiply(axis, point[i]);

    point[i][0] = val[0];
    point[i][1] = val[1];
    point[i][2] = val[2];
}
}

function draw(){//отрисовка 

  for (var i = 0; i < line.length; i++) {
      ctx.moveTo(point_clone[line[i][0]][0]*size_cube, point_clone[line[i][0]][1]*size_cube);
      ctx.lineTo(point_clone[line[i][1]][0]*size_cube, point_clone[line[i][1]][1]*size_cube);
  }
ctx.stroke(); 
}

function clear(){//отчистка экрана 
  ctx.beginPath();
  ctx.clearRect(-300, -300, 600, 600);
}


</script>

</body>
</html>